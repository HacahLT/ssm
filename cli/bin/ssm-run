#!/usr/bin/env node

var program = require('commander')
  , os = require('os')
  , fs = require('fs')
  , path = require('path')
  , util = require('util')
  , async = require('async')
  , minimatch = require("minimatch")
  , glob = require("glob")
  , spawn = require('child_process').spawn;

program
  .option('-w, --walltime <w>', 'walltime in the format hh:mm:ss', '01:00:00')
  .option('-c, --threads <threads>', 'run the design locally using an async queue to process independent tasks in parallel (up to the concurrency limit which default to the number of cpus).', parseInt)
  .option('-d, --cwd', 'current working directory of the child processes.', process.cwd())
  .option('-f, --force', 'just do it.')
  .parse(process.argv);

if (!program.args[0]) {
  console.error('\033[91mFAIL\033[0m: Invalid usage, ssm run <datapackage.json>');
  process.exit(1);
}

//check walltime
if(! (/^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]$/.test(program.walltime))){
  console.error('\033[91mFAIL\033[0m: Invalid walltime format, has to be hh:mm:ss');
  process.exit(1);  
};

var pkg = JSON.parse(fs.readFileSync(path.normalize(program.args[0])));
var pkgRoot = path.dirname(program.args[0]);
var tasks = pkg.analysis[0].data;

//make tasks
var concurrency = (!program.threads) ? os.cpus().length : program.threads;
var walltime = program.walltime.split(':');
walltime = (parseFloat(walltime[0], 10)*60*60 + parseFloat(walltime[1], 10)*60 + parseFloat(walltime[2], 10))*1000;

console.log('\033[94mINFO\033[0m: starting an async queue (concurrency: %d)', concurrency);

////create the queue
//var q = async.queue(function (task, callback) {
//  console.log('\033[94mINFO\033[0m: starting task %d', task.id);
//  runTask(task, walltime, callback);
//}, concurrency);
//
////send the tasks
//tasks.forEach(function(task){
//  q.push(task, function (err) {
//    if(err) console.error('\033[91mFAIL\033[0m: ' +  err);
//  });
//});
//
//q.drain = function(){
//  console.log('\033[94mINFO\033[0m: all the tasks has been processed');
//};


function getPathsFromInputs(inputs, resources, callback){

  async.map(inputs, function(input, cb){
    var names, paths;

    if('resources' in input){      

      names = resources
        .map(function(x){return x.name})
        .filter(minimatch.filter(input.resources, {matchBase: true}));

      paths = resources
        .filter(function(x){return names.indexOf(x.name) !== -1})
        .map(function(x){return path.resolve(pkgRoot, x.path)});

      cb(null, paths);
    } else if ('files' in input){ 

      glob(path.resolve(pkgRoot, input.files), {matchBase: true}, cb);
    } else {
      
      cb(new Error('invalid input'));
    }
  }, function(err, results){    
    if(err) return callback(err);
    callback(null, [].concat.apply([], results));
  });

};


/**
 * return list of object with string content of file + id (taken form
 * filename)
 */
function getFilesFromPaths(inputs, paths, callback){
  async.map(paths, fs.readFile, function(err, files){
    if (err) return callback(err);

    var res;

    if (inputs.collection){
      var data;
      try{
        data = JSON.parse(files[0]);
      } catch(e){
        return callback(e);        
      }

      res = data.map(function(x, i){
        return {id:i.toString(), input: JSON.stringify({resources: x})};
      });

      callback(null, res);

    } else {
      
      res = files.map(function(x, i){
        var id = path.basename(paths[i], path.extname(paths[i])).split('_');
        return {id: id[id.length -1], input: x};
      });

      callback(null, res);
    }

  });
};


function makeTask(mapStep, commandInputs){

  return commandInputs.map(function(x){
    return {
      command: mapStep.command,
      args: [mapStep.argId, x.id].concat(mapStep.args),
      input: x.input,
      outputs: mapStep.outputs //for post processing after task has been completed
      options: {
        cwd: pkgRoot
      }
    }
  });

};

    

/**
 * walltime is in millisec
 */
function runTask(task, walltime, callback){

  //process.stderr.setMaxListeners(0);

  var plomPipe  = spawn(path.join(__dirname, 'plom-pipe'), task.pipeOption)
    , algo = spawn(task.prog, task.progOption);

  prog.stdin.write(JSON.stringify(whatToDo.theta)+'\n', encoding="utf8");

  var timeoutId;

  plomPipe.stdout.pipe(algo.stdin);

//  plomPipe.stderr.pipe(process.stderr);
//  algo.stderr.pipe(process.stderr);
  algo.stdout.resume();

  plomPipe.on('exit', function (code) {
    if (code !== 0) {
      console.error('plom-pipe exited with code ' + code);
      algo.kill();
    } else {

      timeoutId = setTimeout(function(){        
        console.error('\033[93mWARNING\033[0m: walltime overshoot for task %j', task);
        algo.kill();
      }, walltime);
      
    }
  });

  algo.on('exit', function (code) {

    clearTimeout(timeoutId);   

    if (code !== 0) {
      callback(new Error(util.format('sub tasks\n%j\n exited with code %j', task, code)));
    } else {
      console.log('\033[94mINFO\033[0m: sub tasks\n%j\n exited with code %d', task, code);
      callback(null);
    }
  });

};
