#!/usr/bin/env node

var program = require('commander')
  , os = require('os')
  , fs = require('fs')
  , path = require('path')
  , util = require('util')
  , async = require('async')
  , minimatch = require("minimatch")
  , glob = require("glob")
  , spawn = require('child_process').spawn;

program
  .option('-w, --walltime <w>', 'walltime in the format hh:mm:ss', '01:00:00')
  .option('-c, --threads <threads>', 'run the design locally using an async queue to process independent tasks in parallel (up to the concurrency limit which default to the number of cpus).', parseInt)
  .option('-d, --cwd', 'current working directory of the child processes.', process.cwd())
  .option('-f, --force', 'just do it.')
  .parse(process.argv);

if (!program.args[0]) {
  console.error('\033[91mFAIL\033[0m: Invalid usage, ssm run <datapackage.json>');
  process.exit(1);
}

//check walltime
if(! (/^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]$/.test(program.walltime))){
  console.error('\033[91mFAIL\033[0m: Invalid walltime format, has to be hh:mm:ss');
  process.exit(1);  
};

var pkg = JSON.parse(fs.readFileSync(path.normalize(program.args[0])));
var pkgRoot = path.dirname(program.args[0]);
var tasks = pkg.analysis[0].data;

//make tasks
var concurrency = (!program.threads) ? os.cpus().length : program.threads;
var walltime = program.walltime.split(':');
walltime = (parseFloat(walltime[0], 10)*60*60 + parseFloat(walltime[1], 10)*60 + parseFloat(walltime[2], 10))*1000;

console.log('\033[94mINFO\033[0m: starting an async queue (concurrency: %d)', concurrency);

//create the queue
var q = async.queue(function (task, callback) {
  runTask(task, walltime, callback);
}, concurrency);


q.drain = function(){
  console.log('\033[94mINFO\033[0m: all the tasks has been processed');
};


/**
 * For each input of inputs, map an object with a pattern property
 * (optional) and a path property containing a list of path
 * corresponding to pattern
 */
function addPaths(inputs, resources, callback){

  async.map(inputs, function(input, cb){
    var names, paths;

    if('resources' in input){ 

      names = resources
        .map(function(x){return x.name})
        .filter(minimatch.filter(input.resources, {matchBase: true}));

      paths = resources
        .filter(function(x){return names.indexOf(x.name) !== -1})
        .map(function(x){return path.resolve(pkgRoot, x.path)});

      input.paths = paths;

      cb(null, input);
    } else if ('files' in input){ 

      glob(path.resolve(pkgRoot, input.files), {matchBase: true}, function(err, paths){
        input.paths = paths
        cb(err, input);
      });
    } else {
      
      cb(new Error('invalid input'));
    }
  }, callback);

};


/**
 * inputs have an extra paths (list of path property) we add an extra
 * data property ({id: input:})
 */
function addData(inputs, callback){

  async.map(inputs, function(input, cb){

    async.map(input.paths, function(path, cb2){

      fs.readFile(path, function(err, data){
        if(err) return cb2(null, null);
        
        if (input.collection){
          try{
            data = JSON.parse(data);
          } catch(e){
            return cb2(e);        
          }

          data = data.map(function(x, i){
            return {id:i.toString(), input: JSON.stringify(x)};
          });

          cb2(null, data);

        } else {
          
          var re = new RegExp(input.files.replace('*', '(.*)'));
          var id = path.match(re)[1];

          cb2(null, {id: id, input: data});
        }
        
      });
      
    }, function(err, data){
      if(err) return cb(err);
      input.data = data;
      cb(null, input);
    });
       
  }, callback);

};



var map = pkg.analysis[0].data;
var i=0;

(function pushTask(){

  //TODO clean from previous batch task.

  addPaths(map[i].inputs, pkg.resources, function(err){
    addData(map[i].inputs, function(err){

      console.log(i);

      q.push(makeTaskBatch(map[i]), function(err){
        //TODO store results
        
        i++;

        if(i<map.length){        
          pushTask();
        }
        
      });

    })
  });
  
})();




function makeTaskBatch(step){

  var batch = [];

  for(var i=0; i<step.inputs.length; i++){    
    for(var j=0; j<step.inputs[i].data.length; j++){      
      if(step.inputs[i].data[j]){
        batch.push(
          {
            command: step.command,
            args: [step.argsId[0], step.inputs[i].data[j].id].concat(step.args),
            input: inputs[i].data[j].input,
            options: {
              cwd: pkgRoot
            }
          }
        )
      }
    }
  }

  return batch;

};

    

/**
 * walltime is in millisec
 */
function runTask(task, walltime, callback){

  //process.stderr.setMaxListeners(0);

  setTimeout(function(){
    console.log('hello %j', task);
    callback();
  }, 1000);


//  var plomPipe  = spawn(path.join(__dirname, 'plom-pipe'), task.pipeOption)
//    , algo = spawn(task.prog, task.progOption);
//
//  prog.stdin.write(JSON.stringify(whatToDo.theta)+'\n', encoding="utf8");
//
//  var timeoutId;
//
//  plomPipe.stdout.pipe(algo.stdin);
//
////  plomPipe.stderr.pipe(process.stderr);
////  algo.stderr.pipe(process.stderr);
//  algo.stdout.resume();
//
//  plomPipe.on('exit', function (code) {
//    if (code !== 0) {
//      console.error('plom-pipe exited with code ' + code);
//      algo.kill();
//    } else {
//
//      timeoutId = setTimeout(function(){        
//        console.error('\033[93mWARNING\033[0m: walltime overshoot for task %j', task);
//        algo.kill();
//      }, walltime);
//      
//    }
//  });
//
//  algo.on('exit', function (code) {
//
//    clearTimeout(timeoutId);   
//
//    if (code !== 0) {
//      callback(new Error(util.format('sub tasks\n%j\n exited with code %j', task, code)));
//    } else {
//      console.log('\033[94mINFO\033[0m: sub tasks\n%j\n exited with code %d', task, code);
//      callback(null);
//    }
//  });

};
