#!/usr/bin/env node

var program = require('commander')
  , os = require('os')
  , fs = require('fs')
  , mkdirp = require('mkdirp')
  , path = require('path')
  , spawn = require('child_process').spawn
  , resolvePath = require('../lib/util').resolvePath
  , links = require('../lib/links')
  , EventEmitter = require('events').EventEmitter
  , async = require('async');

program
  .option('-o, --output [path]', 'the directory for the builds', resolvePath, path.resolve('ssm_models'))
  .option('-v, --verbose', 'verbose mode')
  .parse(process.argv);

//logging
var emitter = new EventEmitter();
if(program.verbose){
  emitter.on('log', function(msg){
    console.log(msg);
  });
  emitter.on('logEol', function(msg){
    process.stdout.write(msg);
  });
}
emitter.on('error', function(msg){
  console.error('\033[91mFAIL\033[0m: ' + msg);
});
emitter.on('errorEol', function(msg){
  process.stderr.write('\033[91mFAIL\033[0m: ' + msg);
});

emitter.emit('log', 'Building the model locally...');

var pathDpkg;

if(!program.args[0]){
  emitter.emit('error', 'invalid usage, path to datapackage.json is missing (ssm build <path> [options])');
  process.exit(1);
} else {
  pathDpkg = resolvePath(program.args[0]);
}

var dpkgRoot = path.dirname(pathDpkg);
var dpkg;
try {
  dpkg = JSON.parse(fs.readFileSync(pathDpkg));
} catch (e){
  emitter.emit('error', e.message);
  process.exit(1);  
}


//build the models in parallel
async.eachLimit(dpkg.models, os.cpus().length, function(model, cb){
  var pathModel = path.join(program.output, model.name);

  mkdirp(pathModel, function (err) {
    if(err) return cb(err);

    links.resolve(dpkgRoot, dpkg, model.data.concat(model.inputs).filter(function(x){return (('data' in x) && Array.isArray(x.data));}), function(err, rlinks){
      if(err) return cb(err);

      fs.writeFile(path.join(pathModel, '.data.json'), JSON.stringify(rlinks), function(err){
        if(err) return cb(err);
        
        var tplter = [
          "import os",
          "import sys",
          "sys.path.append('" + path.resolve(__dirname, '..', 'src') + "')",
          "from Builder import Builder",
          "path_model_coded_in_C = '" + program.output + "'",
          "path_model_datapackage = '" + pathDpkg + "'",
          "b = Builder(path_model_coded_in_C, path_model_datapackage, '" + model.name + "')",
          "b.prepare()",
          "b.code()",
          "b.write_data()"
        ].join('\n');

        var templater = spawn('python', ['-c', tplter]);
        templater.stdout.setEncoding('utf8');
        templater.stderr.setEncoding('utf8');
        templater.stdout.on('data', function(data){
          emitter.emit('logEol', data);
        });
        templater.stderr.on('data', function(data){
          emitter.emit('errorEol', data);
        });

        templater.on('exit', function (code) {

          if(code === 0) {
            var make = spawn('make', ['install'], {cwd: path.join(pathModel, 'C', 'templates')});
            make.stdout.setEncoding('utf8');
            make.stderr.setEncoding('utf8');
            make.stdout.on('data', function(data){
              emitter.emit('logEol', data);
            });
            make.stderr.on('data', function(data){
              emitter.emit('errorEol', data);
            });

            make.on('exit', function (code) {
              if(code === 0){
                emitter.emit('log','model has been created in ' + pathModel);
              } else {
                emitter.emit('error', 'could not build the model ('+ code +').');
              }
            });
          } else {
            emitter.emit('error', 'could not build the model ('+ code +').');
          }

        });


      });

    });    

  });

}, function(err){
  if(err){
    emitter.emit('error', err.message);
  }
});
